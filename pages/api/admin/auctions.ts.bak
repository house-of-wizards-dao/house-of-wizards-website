import { NextApiRequest, NextApiResponse } from "next";
import { z } from "zod";
import { createApiHandler, validateBody, validateQuery, sendSuccess, sendCreated, ApiErrorCode, ApiValidationError } from "@/lib/api-middleware";
import { requireAdmin, AuthenticatedUser } from "@/lib/auth";
import { getServiceSupabase } from "@/lib/supabase";
import { logger } from "@/lib/logger";

// Validation schemas
const auctionUpdateSchema = z.object({
  title: z.string().min(1, "Title is required").max(255, "Title too long").optional(),
  description: z.string().max(5000, "Description too long").optional(),
  starting_bid: z.number().min(0, "Starting bid must be positive").optional(),
  reserve_price: z.number().min(0, "Reserve price must be positive").optional(),
  minimum_increment: z.number().min(0.001, "Minimum increment must be at least 0.001 ETH").optional(),
  start_time: z.string().datetime().optional(),
  end_time: z.string().datetime().optional(),
  time_buffer_seconds: z.number().min(60, "Time buffer must be at least 60 seconds").max(3600, "Time buffer cannot exceed 1 hour").optional(),
  category: z.string().max(50, "Category too long").optional(),
  tags: z.array(z.string().max(50, "Tag too long")).max(10, "Too many tags").optional(),
  status: z.enum(['upcoming', 'active', 'ended', 'settled', 'cancelled']).optional(),
});

const auctionQuerySchema = z.preprocess((data: any) => {
  return {
    page: data.page || "1",
    limit: data.limit || "20",
    search: data.search,
    status: data.status || "all",
    creator_id: data.creator_id,
    category: data.category,
    sort_by: data.sort_by || "created_at",
    sort_order: data.sort_order || "desc",
  };
}, z.object({
  page: z.string().transform(val => parseInt(val, 10)).refine(val => val > 0, "Page must be positive"),
  limit: z.string().transform(val => parseInt(val, 10)).refine(val => val > 0 && val <= 100, "Limit must be between 1-100"),
  search: z.string().max(255, "Search term too long").optional(),
  status: z.string().refine(val => ['upcoming', 'active', 'ended', 'settled', 'cancelled', 'all'].includes(val), "Invalid status"),
  creator_id: z.string().uuid("Invalid creator ID").optional(),
  category: z.string().max(50, "Category too long").optional(),
  sort_by: z.string().refine(val => ['created_at', 'end_time', 'current_bid', 'title'].includes(val), "Invalid sort field"),
  sort_order: z.string().refine(val => ['asc', 'desc'].includes(val), "Invalid sort order"),
}));

const auctionDeleteSchema = z.object({
  force: z.boolean().optional().default(false), // Hard delete vs soft delete
});

interface AuctionWithDetails {
  id: string;
  title: string;
  description: string;
  artwork_url: string;
  artwork_thumbnail_url?: string;
  starting_bid: number;
  current_bid: number;
  minimum_increment: number;
  reserve_price?: number;
  start_time: string;
  end_time: string;
  time_buffer_seconds: number;
  status: string;
  category: string;
  tags: string[];
  creator_id: string;
  creator_name: string;
  creator_avatar?: string;
  total_bids: number;
  watchers_count: number;
  created_at: string;
  updated_at: string;
  deleted_at?: string;
}

/**
 * GET /api/admin/auctions - List all auctions with pagination and filtering
 */
async function getAuctions(
  req: NextApiRequest,
  res: NextApiResponse,
  user: AuthenticatedUser
) {
  const validatedQuery = validateQuery(auctionQuerySchema)(req);
  const supabase = getServiceSupabase();

  try {
    const { page, limit, search, status, creator_id, category, sort_by, sort_order } = validatedQuery as z.infer<typeof auctionQuerySchema>;
    const offset = (page - 1) * limit;

    // Base query with creator information
    let queryBuilder = supabase
      .from('auctions')
      .select(`
        id,
        title,
        description,
        artwork_url,
        artwork_thumbnail_url,
        starting_bid,
        current_bid,
        minimum_increment,
        reserve_price,
        start_time,
        end_time,
        time_buffer_seconds,
        status,
        category,
        tags,
        creator_id,
        created_at,
        updated_at,
        deleted_at,
        profiles:creator_id (
          name,
          avatar_url
        ),
        bids:bids(count),
        auction_watchers:auction_watchers(count)
      `)
      .is('deleted_at', null); // Only show non-deleted auctions by default

    // Apply filters
    if (search) {
      queryBuilder = queryBuilder.or(
        `title.ilike.%${search}%,description.ilike.%${search}%,category.ilike.%${search}%`
      );
    }

    if (status !== 'all') {
      queryBuilder = queryBuilder.eq('status', status);
    }

    if (creator_id) {
      queryBuilder = queryBuilder.eq('creator_id', creator_id);
    }

    if (category) {
      queryBuilder = queryBuilder.eq('category', category);
    }

    // Apply sorting
    queryBuilder = queryBuilder.order(sort_by, { ascending: sort_order === 'asc' });

    // Get total count for pagination
    const { count } = await supabase
      .from('auctions')
      .select('*', { count: 'exact', head: true })
      .is('deleted_at', null);

    // Apply pagination
    const { data: auctions, error } = await queryBuilder
      .range(offset, offset + limit - 1);

    if (error) {
      logger.error('Failed to fetch auctions', { error, query: validatedQuery });
      throw new Error('Failed to fetch auctions');
    }

    // Transform data to include computed fields
    const transformedAuctions: AuctionWithDetails[] = (auctions || []).map((auction: any) => ({
      ...auction,
      creator_name: auction.profiles?.name || 'Unknown Creator',
      creator_avatar: auction.profiles?.avatar_url,
      total_bids: auction.bids?.[0]?.count || 0,
      watchers_count: auction.auction_watchers?.[0]?.count || 0,
    }));

    const totalPages = Math.ceil((count || 0) / limit);
    const hasMore = page < totalPages;

    sendSuccess(res, transformedAuctions, 'Auctions fetched successfully', {
      page,
      limit,
      total: count || 0,
      hasMore,
    });
  } catch (error) {
    logger.error('Error in getAuctions', { error: error as Error, userId: user.id });
    throw error;
  }
}

/**
 * PUT /api/admin/auctions?id=uuid - Update auction details
 */
async function updateAuction(
  req: NextApiRequest,
  res: NextApiResponse,
  user: AuthenticatedUser
) {
  const { id } = req.query;
  
  if (!id || typeof id !== 'string') {
    throw new ApiValidationError(
      ApiErrorCode.VALIDATION_ERROR,
      'Auction ID is required'
    );
  }

  const updateData = validateBody(auctionUpdateSchema)(req);
  const supabase = getServiceSupabase();

  try {
    // Validate the auction exists and is not deleted
    const { data: existingAuction, error: checkError } = await supabase
      .from('auctions')
      .select('id, status, creator_id')
      .eq('id', id)
      .is('deleted_at', null)
      .single();

    if (checkError || !existingAuction) {
      throw new ApiValidationError(
        ApiErrorCode.NOT_FOUND,
        'Auction not found'
      );
    }

    // Validate business rules
    if (updateData.status && existingAuction.status === 'ended' && updateData.status !== 'ended') {
      throw new ApiValidationError(
        ApiErrorCode.BAD_REQUEST,
        'Cannot change status of ended auction'
      );
    }

    if (updateData.end_time && updateData.start_time) {
      const startTime = new Date(updateData.start_time);
      const endTime = new Date(updateData.end_time);
      
      if (endTime <= startTime) {
        throw new ApiValidationError(
          ApiErrorCode.VALIDATION_ERROR,
          'End time must be after start time'
        );
      }
    }

    if (updateData.reserve_price && updateData.starting_bid && updateData.reserve_price < updateData.starting_bid) {
      throw new ApiValidationError(
        ApiErrorCode.VALIDATION_ERROR,
        'Reserve price cannot be less than starting bid'
      );
    }

    // Perform the update
    const { data: updatedAuction, error: updateError } = await supabase
      .from('auctions')
      .update({
        ...updateData,
        updated_at: new Date().toISOString(),
      })
      .eq('id', id)
      .select(`
        id,
        title,
        description,
        starting_bid,
        current_bid,
        minimum_increment,
        reserve_price,
        start_time,
        end_time,
        time_buffer_seconds,
        status,
        category,
        tags,
        updated_at
      `)
      .single();

    if (updateError) {
      logger.error('Failed to update auction', { error: updateError, auctionId: id, updateData });
      throw new Error('Failed to update auction');
    }

    logger.info('Auction updated successfully', { 
      auctionId: id, 
      updatedBy: user.id,
      changes: Object.keys(updateData)
    });

    sendSuccess(res, updatedAuction, 'Auction updated successfully');
  } catch (error) {
    logger.error('Error in updateAuction', { error: error as Error, auctionId: id, userId: user.id });
    throw error;
  }
}

/**
 * DELETE /api/admin/auctions?id=uuid - Delete or cancel auction
 */
async function deleteAuction(
  req: NextApiRequest,
  res: NextApiResponse,
  user: AuthenticatedUser
) {
  const { id } = req.query;
  
  if (!id || typeof id !== 'string') {
    throw new ApiValidationError(
      ApiErrorCode.VALIDATION_ERROR,
      'Auction ID is required'
    );
  }

  const validatedBody = validateBody(auctionDeleteSchema)(req);
  const { force } = validatedBody as z.infer<typeof auctionDeleteSchema>;
  const supabase = getServiceSupabase();

  try {
    // Check if auction exists and get its current status
    const { data: auction, error: checkError } = await supabase
      .from('auctions')
      .select('id, status, title, total_bids:bids(count)')
      .eq('id', id)
      .is('deleted_at', null)
      .single();

    if (checkError || !auction) {
      throw new ApiValidationError(
        ApiErrorCode.NOT_FOUND,
        'Auction not found'
      );
    }

    const totalBids = auction.total_bids?.[0]?.count || 0;

    // Business rules for deletion
    if (auction.status === 'active' && totalBids > 0 && !force) {
      throw new ApiValidationError(
        ApiErrorCode.BAD_REQUEST,
        'Cannot delete active auction with bids. Use force=true to override or cancel the auction instead.'
      );
    }

    if (force) {
      // Hard delete - remove from database completely
      const { error: deleteError } = await supabase
        .from('auctions')
        .delete()
        .eq('id', id);

      if (deleteError) {
        logger.error('Failed to hard delete auction', { error: deleteError, auctionId: id });
        throw new Error('Failed to delete auction');
      }

      logger.warn('Auction hard deleted', { 
        auctionId: id, 
        auctionTitle: auction.title,
        deletedBy: user.id,
        totalBids
      });
    } else {
      // Soft delete - mark as deleted and cancelled
      const { error: deleteError } = await supabase
        .from('auctions')
        .update({
          deleted_at: new Date().toISOString(),
          status: 'cancelled',
          updated_at: new Date().toISOString(),
        })
        .eq('id', id);

      if (deleteError) {
        logger.error('Failed to soft delete auction', { error: deleteError, auctionId: id });
        throw new Error('Failed to delete auction');
      }

      logger.info('Auction soft deleted', { 
        auctionId: id, 
        auctionTitle: auction.title,
        deletedBy: user.id,
        totalBids
      });
    }

    sendSuccess(res, { 
      id, 
      deleted: true, 
      force,
      message: force ? 'Auction permanently deleted' : 'Auction cancelled and archived'
    }, 'Auction deleted successfully');
  } catch (error) {
    logger.error('Error in deleteAuction', { error: error as Error, auctionId: id, userId: user.id });
    throw error;
  }
}

/**
 * Main handler that routes to appropriate function based on HTTP method
 */
async function auctionsHandler(
  req: NextApiRequest,
  res: NextApiResponse,
  user: AuthenticatedUser
) {
  switch (req.method) {
    case 'GET':
      return getAuctions(req, res, user);
    case 'PUT':
      return updateAuction(req, res, user);
    case 'DELETE':
      return deleteAuction(req, res, user);
    default:
      throw new ApiValidationError(
        ApiErrorCode.BAD_REQUEST,
        `Method ${req.method} not allowed`
      );
  }
}

// Export the handler with proper middleware
const handler = createApiHandler(requireAdmin(auctionsHandler), {
  methods: ['GET', 'PUT', 'DELETE'],
  cors: true,
});

export default handler;